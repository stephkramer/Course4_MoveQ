---
title: "Tutorial Part IV — Getting started with animal movement"
author: "Stephanie Kramer-Schadt"
date: "`r Sys.setlocale('LC_TIME','C'); paste('Last Update', format(Sys.time(), '%B %e, %Y')) `" 
        #"`r Sys.Date()`" # 
output:
  rmdformats::readthedown:
    highlight: kate
    code_folding: show
    toc_depth: 4
    toc_float: true
editor_options:
  chunk_output_type: console
params:
  date: !r Sys.Date()
---

<style>
h1 {
  color: Orange ;
}
h2, h3, h4, h5, h6, legend {
  color: Indigo ;
}

#sidebar h2 {
  background-color: Indigo;
}
</style>
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
#knitr::opts_knit$set(root.dir = 'C:/Users/kramer/PopDynIZW Dropbox/Steph Kramer/_GitHub/Course4_MoveQ')
```

# Introduction

In this tutorial, I will show you how to get started with (real) animal movement data. 
To put it simple, animal movement data are just points in time and space, i.e. re-locations
of an individual can be provided as a *data.frame* with four columns. An
identifier for the individual is only needed if you have different animals in one 
data set, i.e. if you have collared several individuals with the same collar or
already appended several data sets:

Identifier    | Timestamp           | x_coordinate    | y_coordinate    
------------- | ------------------- | --------------- | ---------------   
Fox_1         | 2022-01-01 08:10:04 | 13.47027        | 52.497802
Fox_1         | 2022-01-01 08:15:04 | 13.47015        | 52.497813


From [Course2_SpatialR](https://github.com/stephkramer/Course2_SpatialR), 
you might remember that these can be imported 
as simple .txt or .csv files. Once you know in which coordinate reference system (CRS)
your coordinates are stemming from, you can **assign** it to the *data.frame*, thereby
you are creating a geo-referenced data set: a *SpatialPointsDataframe* - Object (if
you work with the R-package `{sp}`) or an *sf* - Object (with package `{sf}`). 
Looking at these x- and y-coordinates, you might remember that they look like 
angular units, e.g. decimal degrees, and the x-coordinate refers to longitude and the
y-coordinate to latitude. Hence, we are dealing with EPSG-code 4326. 
Once you have imported and georeferenced your data, you can plot and thoroughly check the data.

Checking your data is a mandatory prerequisite before any analysis (see 
Zuur et al. 2010). With your movement data, you might have outliers in space 
(e.g. when you test your collars in location A which might be hundreds of kilometers from your actual trapping site), your data might not have been regularly sampled because the animal was hiding and
there was no access to the satellite (weak GPS-signal) etc etc. This uneven 
sampling can affect calculations of speed, for example, and therefore a series of packages
have been developed to deal with those issues in movement data, like `{move}`. 

The most prominent movement analyses comprise home range estimation, calculations of
habitat preference, behavioral analyses (e.g. Hertel et al. 2021) and
detection of movement syndromes (personality differences) (Michelangeli et al. 2021).
Some of the packages listed in the next chapter are designed for these analyses. 

TODO plot pic (fox_Q_20190113_sks.jpg "fox q") funktioniert nicht

[TODO - exchange Q with Caro's foxes, ref PhD C Scholz]

In the following, we will step by step start with loading and exploring movement data
of female red fox (*Vulpes vulpes*) 'Q von Stralau', who had a small home range 
in Berlin, Germany. She was collared in January 2018 and had a very stable daily routine
as shown by 4 (20) min relocation intervals. We will, however, only use the data of one month
in this exercise, as data sets quickly get too big. Please note: the courses
[Course1_IntroR](https://github.com/stephkramer/Course1_IntroR) and [Course2_SpatialR](https://github.com/stephkramer/Course2_SpatialR) are 
obligatory for this tutorial.

 
## Useful (web)sites and reading

*  For analysis of telemetry data: packages **adehabitatHR, adehabitatLT, move,recurse, momentuHMM, moveHMM, ctmm, amt**

<br>

* Hertel, AG, Royauté, R, Zedrosser, A, Mueller, T. Biologging reveals individual variation in behavioural predictability in the wild. J Anim Ecol. 2021; 90: 723– 737. https://doi.org/10.1111/1365-2656.13406

* Joo, R, Boone, ME, Clay, TA, Patrick, SC, Clusella-Trullas, S, Basille, M. Navigating through the r packages for movement. J Anim Ecol. 2020; 89: 248– 267. https://doi.org/10.1111/1365-2656.13116

* Kimmig, S (2021). xxx, PhD thesis, FU Berlin.

*  Michelangeli, M., Payne, E., Spiegel, O., Sinn, D. L., Leu, S. T., Gardner, M. G., & Sih, A. (2021). Personality, spatiotemporal ecological variation and resident/explorer movement syndromes in the sleepy lizard. Journal of Animal Ecology, 00, 1– 14. https://doi.org/10.1111/1365-2656.13616

* Scholz, C (2020). The ecology of red foxes (*Vulpes vulpes*) in anthropogenic
environments. PhD thesis, FU Berlin.

* Zuur, A.F., Ieno, E.N. and Elphick, C.S. (2010), A protocol for data exploration to avoid common statistical problems. Methods in Ecology and Evolution, 1: 3-14. https://doi.org/10.1111/j.2041-210X.2009.00001.x
   

# Getting started

To follow the tutorial, you can either clone or download the repository at
https://github.com/stephkramer/Course4_MoveQ
or you create your own R-project, copy the raw data and type the code chunks into an R-Script.
Please refer to the section on using R-projects in [Course2_RSpatial](https://github.com/stephkramer/Course2_SpatialR).

If you start with your own R-project, I strongly recommend to use the d6-package 
Cedric Scherer provided. This package automatically sets up the ideal folder structure:
https://github.com/EcoDynIZW/d6

In any case, my course folder has the following structure:  

``` bash
.
└── Course4_MoveQ
    ├── data-raw (contains the file with the GPS locations)
    ├── docs
    ├── output
    ├── plots
    └── R (contains the R-script)

```

## Necessary packages to install and load

We first have to install the packages and load them before we can use the
functions we need.


```{r}
# package names:
pkgs = c("here", "sp", "sf", "dismo", "raster", "GISTools",  "rgdal", 
         "maptools", "rgeos","rgl","rasterVis", "adehabitatHR", "move", "tmap",
         "plotly", "circular","gganimate","moveVis", "ggmap", "maps", "mapproj",
         "viridis","dplyr", "devtools","lubridate", "patchwork",
         "colorspace","ragg", "ggtext","pdftools", "units",
         "glue", "cowplot", "tidyverse", "ggplot2", "Cairo") 

# install.packages(pkgs) # only run this line once for installing the packages!
# update.packages()
```
<br>

Tip of the day: If you have already installed some of the packages above, you can
first check which ones are already installed, and save the ones *not installed* in 
an object called <my_packages> and only install the missing ones:

```{r}
# my_packages <- pkgs[!(pkgs %in% installed.packages()[,"Package"])]
# my_packages
# if(length(my_packages) > 0) install.packages(my_packages)
```

Now load the packages:

```{r libraries, warning=FALSE}
library(here) #for easy directory management
library(sp)
library(dismo)
library(raster)
library(GISTools)
library(rgdal)    # retiring end of 2023 -> use stars/ terra /sf
library(maptools) # retiring end of 2023 -> use sp
library(rgeos)    # retiring end of 2023 -> use sf
library(rgl)
library(rasterVis)
library(adehabitatHR)  #adehabitatLT  #adehabitatMA                           
library(sf)
library(move)
library(plotly)
library(circular)
library(dplyr)
library(tmap)
library(viridis) 
library(gganimate)
library(ggplot2)
library(moveVis)
library(ggmap)
library(maps)  
library(mapproj)
library(devtools)
library(lubridate) 
library(here)
library(glue)
library(cowplot)
library(tidyverse)
library(Cairo)
library(colorspace)
library(ragg)
library(ggtext)
library(pdftools)
library(units)
library(ggplot2)
library(patchwork) # to combine plots
```

## Set the working environment

Now that we are working inside an R-project, we can use the easy functionality
of the `{here}` package, which is automatically pointing to your project's root
folder, e.g.:

```{r}
here::here() 
```

Hence, there is no need to use the function *setwd()* any more.
Note: if it does not work, please close RStudio, go to your Explorer and 
double-click on the .Rproj file. Then, under 'files' (usually lower right panel) 
double-click on the R folder and open the script.

## Load data

The movement data are stored in the data-raw subfolder. Let's check which
files are available. 

```{r}
lf <- list.files(path=here("data-raw"), full.names=TRUE) 
lf
```

The output lists two results, [1] is another subfolder, and [2] a text file. If
you already know that your movement data contain e.g. 'gps' in their names or
are stored as '.txt' or '.csv' files, you can directly search for those files with the
*pattern* argument:

```{r}
# check the difference, and note: full.names was set to FALSE
list.files(path=here("data-raw"),pattern='gps',full.names=FALSE)
```

Now load the data file. 
```{r}
dat_anim <- read.table(file=lf[2], header=TRUE, fill=TRUE, sep=',')
```

### Data check

Let's have a look at the data. This is the typical data stored on e-obs collars:
```{r}
dat_anim[1:5,] # recap: head(dat_anim) also works
```
For now, we will only work with few columns. **tag.serial.number** here refers to the 
individual identifier (collar ID). There are two columns with timestamps. 
**start.timestamp** is the preprogrammed time-interval. Then there is the
**timestamp.of.fix**, which is the real time the GPS-location was recorded. 
This is usually a bit later, i.e. 
<br>
( = **start.timestamp** + **used.time.to.get.fix** + 1 second), as it takes some
time for the collar unit to connect to the satellite. The spatial info is stored
in the columns **longitude** and **latitude**.

Before you can transform the *data.frame* 'dat_anim' into a georeferenced 
spatial object, you need to check whether there are missing locations in your *data.frame*,
otherwise you will get an error message on transformation.
**This can happen if no GPS-signal could be recorded. Or - importantly - some collars
are only activated when the animal is moving to save battery life. In that case,
the missing GPS coordinates would correspond with the last position (= be the same).
Depending on which analysis you want to do, e.g. define resting places, you might need to fill
the missing positions again.**

```{r}
# if the latitude-entry is missing, the longitude value will also be missing
# so it is enough to only check the latitude
which(is.na(dat_anim$latitude)) #there are a lot of missing values in the locations
dat_anim_na <- dat_anim[!is.na(dat_anim$latitude),] #alternatively, use complete.cases()
```

Make the crosscheck if there is missing data in longitude:
```{r}
which(is.na(dat_anim_na$longitude)) # none
```

### Data preparation

We will now add some additional columns, where separate days (numbered from 1 to
365), the month (from 1 to 12) and the hour of the day are stored (1 - 23). This can be 
done with the package ´{lubridate}´. Check the [vignette](https://cran.r-project.org/web/packages/lubridate/vignettes/lubridate.html)!

```{r}
# define date-time format - the format is year-month-day_hour:min:sec:
dat_anim_na$start.timestamp <- ymd_hms(dat_anim_na$start.timestamp, tz="Europe/Berlin")  
```

Now append the information:

```{r}
dat_anim_na$yearday <- yday(dat_anim_na$start.timestamp)
dat_anim_na$month   <- month(dat_anim_na$start.timestamp)
dat_anim_na$hour    <- hour(dat_anim_na$start.timestamp)
dat_anim_na$kweek   <- week(dat_anim_na$start.timestamp)
# crosscheck with
# head(dat_anim_na)
```

In addition, we want to calulate the hours of sunset and sunrise as well as daylength.
For this, we need to install a package that is still under development, i.e.
which is not on CRAN. We therefore must download and install it locally:

```{r}
# devtools::install_github("bgctw/solartime") # run only once
library(solartime)
```
For computing sunset and sunrise, the latitude/ longitude must be provided as well:
```{r}
dat_anim_na$sunrise   <- computeSunriseHour(timestamp = dat_anim_na$start.timestamp,
                                            latDeg = dat_anim_na$latitude,
                                            longDeg = dat_anim_na$longitude)
dat_anim_na$sunset    <- computeSunsetHour(dat_anim_na$start.timestamp,
                                           dat_anim_na$latitude,
                                           dat_anim_na$longitude)
dat_anim_na$daylength <- computeDayLength(dat_anim_na$start.timestamp,dat_anim_na$latitude)
dat_anim_na$daytime   <- computeIsDayByLocation(dat_anim_na$start.timestamp,
                                                dat_anim_na$latitude,
                                                dat_anim_na$longitude)
# head(dat_anim_na)
```


### Data transformation

Now we can transform the data into *sf* and *sp* objects and **assign** 
the coordinate reference system:
```{r}
# transform into spatial simple feature sf object
mydf_sf <- st_as_sf(x = data.frame(dat_anim_na),
                       coords = c("longitude", "latitude"),
                       crs = 4326,
                       sf_column_name = "geometry" )

# transform into SpatialPointsDataFrame  - for crosschecking
mydf_sp <- as(mydf_sf, "Spatial") 
```

And then we **project** the reference system from angular units to a planar
coordinate reference system in meters:

```{r}
# transform CRS to projected one in meter distance units
mydf_sf_trans <-  st_transform(mydf_sf, 5631 )  # EPSG-code Pulkovo 
mydf_sp_trans <-  spTransform(mydf_sp, CRS("+init=epsg:5631"))
```

# Data exploration

## Plot the data

This is recap from Course2. A quick plot from the simple *data.frame*
```{r}
# latitude is y-Axis, longitude = x-axis in cartesian coordinate system
plot(dat_anim_na$latitude ~ dat_anim_na$longitude,
       pch='.',
       col=as.numeric(dat_anim_na$daytime)+1 # + 1 because color 0 is transparent
     )
```

 A quick plot of the movement path, using only the first 50 rows
```{r}
plot(dat_anim_na$latitude[1:50] ~ dat_anim_na$longitude[1:50], type= 'l') 
```

Much nicer with ggplot and the projected sf object:
```{r}
baseplot <- ggplot(data = mydf_sf_trans) +
              geom_sf(aes(color = daytime),size=0.01, alpha=0.5)   +  
              xlab("Longitude") + ylab("Latitude") +
              ggtitle("Telemetry data")
baseplot
```

We can even add contour lines of the point density:
TODO - error here - duplicated aes
```{r}
densplot <- baseplot + stat_density_2d(
                         aes(x = st_coordinates(mydf_sf_trans)[,1], 
                             y = st_coordinates(mydf_sf_trans)[,2],
                         alpha = ..level..,
                         color = after_scale(colorspace::darken(color, .5, space = "HLS")),
                         fill  = after_scale(colorspace::lighten(color, .4, space = "HLS"))), 
                         geom  = "polygon",
                         color = "white" ,
                         size  = .02,
                         n     = 500,
                         bins  = 5,
                         adjust = 3,
                         data  = mydf_sf_trans)  
densplot

# example of how to save the plot to your file
# ggsave(here("plots","plot_pointdensity.png"), dpi = 800, height = 6, width = 6)
```

We can also add background using ggmap. Check here for a quick start to ggmap:
 https://www.nceas.ucsb.edu/sites/default/files/2020-04/ggmapCheatsheet.pdf

```{r}
# define abounding box for the plot
b <- c(13.460,52.485,13.490,52.500) # make large enough to plot all data!

t <- get_map(location = b, maptype = "terrain", source='osm', zoom = 15)

(ggmap(t) 
  + geom_point(aes(x = longitude, y = latitude), 
               data = data.frame(dat_anim_na), 
               colour = as.numeric(dat_anim_na$daytime)+5, 
               size = 0.05)
  + labs(x="Latitude", y="Longitude", title="telemetry locations") 
)

```

Last but not least and much quicker, the ´{tmap}´package can help, but you need
an sf/sp-object:

```{r}
tmap_mode(mode = "view")
  tm_shape(shp = mydf_sf_trans)  + tm_dots(size = 0.01, 
                                           col = 'daytime',  
                                           alpha=0.5) 

```

Have a deep look at the data: did the fox really swim? (points in Lake Rummelsburg).
Or are these outliers? No: the lake was frozen! Note: you really need to know your 
animal and the area!

# END

Adding the session info can be very helpful when going back to old scripts or 
using scripts of others:

```{r session-info}
sessionInfo()
```

