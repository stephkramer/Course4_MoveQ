# package names:
pkgs = c("here", "sp", "sf", "dismo", "raster", "GISTools",  "rgdal",
"maptools", "rgeos","rgl","rasterVis", "adehabitatHR", "move", "tmap",
"plotly", "circular","gganimate","moveVis", "ggmap", "maps", "mapproj",
"viridis","dplyr", "devtools","lubridate", "patchwork","gower",
"colorspace","ragg", "ggtext","pdftools", "units", "leaflet",
"glue", "cowplot", "tidyverse", "ggplot2", "Cairo")
# install.packages(pkgs) # only run this line once for installing the packages!
# update.packages()
my_packages <- pkgs[!(pkgs %in% installed.packages()[,"Package"])]
my_packages
if(length(my_packages) > 0) install.packages(my_packages)
library(here) #for easy directory management
library(sp)
library(dismo)
library(raster)
library(GISTools)
library(rgdal)    # retiring end of 2023 -> use stars/ terra /sf
library(maptools) # retiring end of 2023 -> use sp
library(rgeos)    # retiring end of 2023 -> use sf
library(rgl)
library(rasterVis)
library(adehabitatHR)  #adehabitatLT  #adehabitatMA
library(sf)
library(move)
library(plotly)
library(circular)
library(dplyr)
library(tmap)
library(viridis)
library(gganimate)
library(ggplot2)
library(moveVis)
library(ggmap)
library(maps)
library(mapproj)
library(devtools)
library(lubridate)
library(here)
library(glue)
library(cowplot)
library(tidyverse)
library(Cairo)
library(colorspace)
library(ragg)
library(ggtext)
library(pdftools)
library(units)
library(ggplot2)
library(patchwork) # to combine plots
library(leaflet)
library(gower)
lf <- list.files(path=here("data-raw"), full.names=TRUE)
lf
# check the difference, and note: full.names is set to FALSE
thefile <- list.files(path=here("data-raw"),pattern='gps',full.names=FALSE)
thefile
# ...and here to TRUE
thefullfile <- list.files(path=here("data-raw"),pattern='gps',full.names=TRUE)
thefullfile
here::here()
lf <- list.files(path=here("data-raw"), full.names=TRUE)
lf
# check the difference, and note: full.names is set to FALSE
thefile <- list.files(path=here("data-raw"),pattern='gps',full.names=FALSE)
thefile
# ...and here to TRUE
thefullfile <- list.files(path=here("data-raw"),pattern='gps',full.names=TRUE)
thefullfile
# let's get the number of the list in lf that corresponds with the filename.
# Tip of the day: always code everything you can, do not insert numbers or filenames
# by hand, i.e. lf[2]. If you for example add new data, the numbering changes!
lf_number <- which(lf == thefullfile)
dat_anim <- read.table(file=lf[lf_number], header=TRUE, fill=TRUE, sep=',')
# or, since with 'thefullfile' you gave the complete path, you can also directly load it
#dat_anim <- read.table(file=thefullfile, header=TRUE, fill=TRUE, sep=',')
dat_anim[1:5,] # recap: head(dat_anim) also works
# if the latitude-entry is missing, the longitude value will also be missing
# so it is enough to only check the latitude
which(is.na(dat_anim$latitude)) #there are a lot of missing values in the locations
dat_anim_na <- dat_anim[!is.na(dat_anim$latitude),] #alternatively, use complete.cases()
which(is.na(dat_anim_na$longitude)) # none
plot(dat_anim_na$latitude ~ dat_anim_na.longitude)
plot(dat_anim_na$latitude ~ dat_anim_na$longitude)
# have a look at the timestamp format, here the first row of the column start.timestamp
dat_anim_na$start.timestamp[1]
# define date-time format - the format is year-month-day_hour:min:sec:
dat_anim_na$start.timestamp <- ymd_hms(dat_anim_na$start.timestamp, tz="Europe/Berlin")
dat_anim_na$start.timestamp[1]
dat_anim_na$yearday <- yday(dat_anim_na$start.timestamp)
dat_anim_na$month   <- month(dat_anim_na$start.timestamp)
dat_anim_na$hour    <- hour(dat_anim_na$start.timestamp)
dat_anim_na$kweek   <- week(dat_anim_na$start.timestamp)
dat_anim_na$date    <- date(dat_anim_na$start.timestamp)
# crosscheck with
# head(dat_anim_na)
# devtools::install_github("bgctw/solartime") # run only once
library(solartime)
dat_anim_na$sunrise   <- computeSunriseHour(timestamp = dat_anim_na$start.timestamp,
latDeg = dat_anim_na$latitude,
longDeg = dat_anim_na$longitude)
dat_anim_na$sunset    <- computeSunsetHour(dat_anim_na$start.timestamp,
dat_anim_na$latitude,
dat_anim_na$longitude)
dat_anim_na$daylength <- computeDayLength(dat_anim_na$start.timestamp,dat_anim_na$latitude)
dat_anim_na$daytime   <- computeIsDayByLocation(dat_anim_na$start.timestamp,
dat_anim_na$latitude,
dat_anim_na$longitude)
# head(dat_anim_na)
table(dat_anim_na$date)  #  there is a strange date - 2025-12-26
# Delete data row
delme <- which(dat_anim_na$date == '2025-12-26')
dat_anim_na[delme,]
dat_anim_na <- dat_anim_na[-delme,] # delete the strange date and
table(dat_anim_na$date)             # check again
plot(table(dat_anim_na$date))       # plot the number of fixes per day
# R data file - can only be opened/ read with R by using function readRDS()
saveRDS(dat_anim_na, file = here('output/data-proc/tag5334_gps_proc.Rds'))
# interchange file format .csv
write.csv(dat_anim_na, file = here('output/data-proc/tag5334_gps_proc.csv'))
?load
anim_proc <- load(file = here('output/data-proc/tag5334_gps_proc.Rds'))
# R data file - can only be opened/ read with R by using function readRDS()
saveRDS(dat_anim_na, file = here('output/data-proc/tag5334_gps_proc.Rds'))
# interchange file format .csv
write.csv(dat_anim_na, file = here('output/data-proc/tag5334_gps_proc.csv'))
?readRDS
anim_proc <- readRDS(file = here('output/data-proc/tag5334_gps_proc.Rds'))
anim_proc
head(anim_proc)
plot(table(anim_proc$date))
plot(table(anim_proc$date))
plot(table(anim_proc$yearday))
plot(table(anim_proc$hour))       # plot the number of fixes per hour
# simple
timetoplot <- circular(anim_proc$hour%%24, # convert to 24 hrs = bins
units="hours", template="clock24")
rose.diag(timetoplot, bin=24, col="blue",
main="Events by Hour (sqrt scale)", prop=3)
# with ggplot
# code adapted from https://gist.github.com/mattbaggott/4361381
ggplot(anim_proc,aes(x=hour,fill=daytime))+
geom_bar(breaks=seq(0,24),width = 2,colour="grey")+
coord_polar(start=0)+
theme_minimal()+
scale_fill_brewer()+
ylab("Count")+
ggtitle("Events by Time of day")+
scale_x_continuous("", limits=c(0,24),
breaks=seq(0,24),
labels=seq(0,24))
# transform into spatial simple feature sf object
mydf_sf <- st_as_sf(x = data.frame(anim_proc),
coords = c("longitude", "latitude"),
crs = 4326,
sf_column_name = "geometry" )
# transform into SpatialPointsDataFrame  - for crosschecking
mydf_sp <- as(mydf_sf, "Spatial")
# transform CRS to projected one in meter distance units
mydf_sf_trans <-  st_transform(mydf_sf, 5631 )  # EPSG-code Pulkovo
mydf_sp_trans <-  spTransform(mydf_sp, CRS("+init=epsg:5631"))
# transform CRS to projected one in meter distance units
mydf_sf_trans <-  st_transform(mydf_sf, 3035 )  # EPSG-code
mydf_sp_trans <-  spTransform(mydf_sp, CRS("+init=epsg:3035"))
tmap_mode(mode = "view")
tm_shape(shp = mydf_sf_trans)  + tm_dots(size = 0.01,
col = 'daytime',
alpha=0.5)
my_fox <- move(x=anim_proc$longitude, y= dat_anim_na$latitude,
time=anim_proc$date,
proj= CRS("+proj=longlat"),data=dat_anim_na,animal="FoxQvonStralau"  )
head(my_fox); nrow(my_fox)
my_fox <- move(x=anim_proc$longitude, y= dat_anim_na$latitude,
time=anim_proc$date,
proj= CRS("+proj=longlat"),data=dat_anim_na,animal="FoxQvonStralau")
# head(my_fox); nrow(my_fox)
my_fox <- move(x=anim_proc$longitude, y= dat_anim_na$latitude,
time=as.POSIXct(animal$date,format="%Y-%m-%d %H:%M:%S"),
proj= CRS("+proj=longlat"),data=dat_anim_na,animal="FoxQvonStralau")
# head(my_fox); nrow(my_fox)
?move
my_fox <- move(x=anim_proc$longitude, y= dat_anim_na$latitude,
time=as.POSIXct(animal$start.timestamp,format="%Y-%m-%d %H:%M:%S"),
proj= CRS("+proj=longlat"),data=dat_anim_na,animal="FoxQvonStralau")
# head(my_fox); nrow(my_fox)
my_fox <- move(x=anim_proc$longitude, y= dat_anim_na$latitude,
time=as.POSIXct(animal$start.timestamp,format="%Y-%m-%d %H:%M:%S"),
proj= CRS("+proj=longlat"),data=anim_proc,animal="FoxQvonStralau")
# head(my_fox); nrow(my_fox)
my_fox <- move(x=longitude, y= latitude,
time=as.POSIXct(start.timestamp,format="%Y-%m-%d %H:%M:%S"),
proj= CRS("+proj=longlat"),
data=anim_proc,
animal="FoxQvonStralau")
# head(my_fox); nrow(my_fox)
my_fox <- move(x = anim_proc$longitude, y = anim_proc$latitude,
time=as.POSIXct(anim_proc$start.timestamp,format="%Y-%m-%d %H:%M:%S"),
proj= CRS("+proj=longlat"),
data=anim_proc,
animal="FoxQvonStralau")
# head(my_fox); nrow(my_fox)
my_fox <- move(x = anim_proc$longitude, y = anim_proc$latitude,
time = anim_proc$date,
#time=as.POSIXct(anim_proc$start.timestamp,format="%Y-%m-%d %H:%M:%S"),
proj= CRS("+proj=longlat"),
data=anim_proc,
animal="FoxQvonStralau")
# head(my_fox); nrow(my_fox)
my_fox <- move(x = anim_proc$longitude, y = anim_proc$latitude,
time=as.POSIXct(anim_proc$start.timestamp,format="%Y-%m-%d %H:%M:%S"),
proj= CRS("+proj=longlat"),
data=anim_proc,
animal="FoxQvonStralau")
# head(my_fox); nrow(my_fox)
timeLag(my_fox, unit = "mins")[1:5] # varies a lot, but minimum here 20 min
min(timeLag(my_fox, units="mins"))
mean(timeLag(my_fox, units="mins"))
max(timeLag(my_fox, units="mins"))
?speed
steplength <- distance(my_fox) #know your units!
hist(steplength)
hist(speed(my_fox))
hist(steplength)
max(steplength)
data(leroy)
behav <- c(rep(c("B1","B2","B3","B2"),each=200), rep("B1", 118))
testb <- burst(x=leroy, f=behav)
plot(testb, type="l")
hrBootstrap(my_fox,rep=5, level=99, unout="m2", plot=TRUE)
my_fox
head(mydf_sp_trans)
hrBootstrap(my_fox,rep=5, level=99, unout="m2", plot=TRUE)?mcp
?mcp
(my_fox[,'daytime']
)
my_fox[,'daytime']
cp <- mcp(my_fox[,'daytime'], percent=95) # Minimum Convex Polygon (95%) per TierID # set unout
cp
nrow(my_fox)
,mydf_sp_trans
mydf_sp_trans
head(mydf_sp_trans)
# TODO - something is wrong here with the units!!!! check the warning online
hrBootstrap(mydf_sp_trans,rep=5, level=99, unout="m2", plot=TRUE)
# TODO - something is wrong here with the units!!!! check the warning online
hrBootstrap(my_fox,rep=5, level=99, unout="m2", plot=TRUE)
cp <- mcp(mydf_sp_trans[,'daytime'], percent=95) # Minimum Convex Polygon (95%) per TierID # set unout
cp <- mcp(mydf_sp_trans[,'daytime'], percent=95) # Minimum Convex Polygon (95%) per TierID # set unout
cp
my_fox <- move(x = anim_proc$longitude, y = anim_proc$latitude,
time=as.POSIXct(anim_proc$start.timestamp,format="%Y-%m-%d %H:%M:%S"),
proj= CRS("+init=epsg:4326),
data=anim_procC,
animal="FoxQvonStralau")
# head(my_fox); nrow(my_fox)
my_fox <- move(x = anim_proc$longitude, y = anim_proc$latitude,
time=as.POSIXct(anim_proc$start.timestamp,format="%Y-%m-%d %H:%M:%S"),
proj= CRS("+init=epsg:4326"),
data=anim_proc,
animal="FoxQvonStralau")
# head(my_fox); nrow(my_fox)
timeLag(my_fox, unit = "mins")[1:5] # varies a lot, but minimum here 20 min
min(timeLag(my_fox, units="mins"))
mean(timeLag(my_fox, units="mins"))
max(timeLag(my_fox, units="mins"))
turnang <- angle(my_fox)
# turnang <- turnAngleGc(my_fox) # the same
# using the absolute abs(), because -180 and 180 has similar meaning: the animal turns sharply
hist(abs(turnang))
?recurse
# TODO - something is wrong here with the units!!!! check the crs warning online
hrBootstrap(my_fox,rep=5, level=99, unout="m2", plot=TRUE)
# TODO - something is wrong here with the units!!!! check the crs warning online
hrBootstrap(my_fox,rep=5, level=99, unout="ha", plot=TRUE)
# TODO - something is wrong here with the units!!!! check the crs warning online
hrBootstrap(my_fox,rep=5, level=99, unout="km2", plot=TRUE)
8e-05
as.numeric(8e-05)
8e-05*100000
cp <- mcp(mydf_sp_trans[,'daytime'], percent=95) # Minimum Convex Polygon (95%) per TierID # set unout
cp
cp <- mcp(mydf_sp_trans[,'daytime'], percent=95, unout='km2') # MCP (95%) per daytime # set unout
cp
cp_daytime <- mcp(mydf_sp_trans[,'daytime'], percent=95, unout='km2') # MCP (95%)
cp_daytime
cp_month <- mcp(mydf_sp_trans[,'month'], percent=95, unout='km2') # MCP (95%)
cp_month
cp_daytime <- mcp(mydf_sp_trans[,'daytime'], percent=95, unout='km2') # MCP (95%)
cp_daytime
plot(cp)
cp_daytime <- mcp(mydf_sp_trans[,'daytime'], percent=95, unout='km2') # MCP (95%)
cp_daytime
plot(cp)
plot(mydf_sp_trans, add=TRUE, col= 'red')
cp_daytime <- mcp(mydf_sp_trans[,'daytime'], percent=95, unout='km2') # MCP (95%)
cp_daytime
plot(cp)
plot(mydf_sp_trans, add=TRUE, col= as.numeric(mydf_sp_trans$daytime))
cp_daytime <- mcp(mydf_sp_trans[,'daytime'], percent=95, unout='km2') # MCP (95%)
cp_daytime
plot(cp)
plot(mydf_sp_trans, add=TRUE, col= as.numeric(mydf_sp_trans$daytime)+1)
cp_daytime
cp_daytime <- mcp(mydf_sp_trans[,'daytime'], percent=95, unout='m2') # MCP (95%)
cp_daytime
plot(cp)
plot(mydf_sp_trans, add=TRUE, col= as.numeric(mydf_sp_trans$daytime)+1)
cp_daytime <- mcp(mydf_sp_trans[,'daytime'], percent=95, unout='km2') # MCP (95%)
cp_daytime
plot(cp)
plot(mydf_sp_trans, add=TRUE, col= as.numeric(mydf_sp_trans$daytime)+1)
str(cp_daytime)
mcp_daytime <- mcp(mydf_sp_trans[,'daytime'], percent=95, unout='km2') # MCP (95%)
mcp_daytime
plot(mcp_daytime)
plot(mydf_sp_trans, add=TRUE, col= as.numeric(mydf_sp_trans$daytime)+1)
str(mcp_daytime)
str(mcp_daytime)
plot(mcp_daytime@polygons[1])
here()
mcp_daytime <- mcp(mydf_sp_trans[,'daytime'], percent=95, unout='km2') # MCP (95%)
mcp_daytime
hrs <- mcp.area(mydf_sp_trans[,'daytime'], percent=seq(50, 100, by = 5),unout='km2')
hrs # home range size in km2 for the different MCP-levels
plot(mcp_daytime)
plot(mydf_sp_trans, add=TRUE, col= as.numeric(mydf_sp_trans$daytime)+1)
outmcp_daytime@polygons[1]
mcp_daytime@polygons[1]
str(mcp_daytime)
writeOGR(mcp_daytime, dsn=here(output,data-proc),
"mcp95_daytime_foxQ",'ESRI Shapefile',overwrite=T) #save as ESRI shapefile
here(output,data-proc)
str(mcp_daytime)
writeOGR(mcp_daytime, dsn=here('output','data-proc'),
"mcp95_daytime_foxQ",'ESRI Shapefile',overwrite=T) #save as ESRI shapefile
?hrBootstrap
# TODO - something is wrong here with the units!!!! check the crs warning online
hrBootstrap(mydf_sp_trans,rep=5, level=99, unout="km2", plot=TRUE)
kud <- kernelUD(mydf_sp_trans[,'daytime'], h="href") # calculate kernel with h="href",
?kernelUD
mydf_sp_trans
kud
kernel.area(kud,unout='km2')
homerange2 <- getverticeshr(kud,percent = 90)
homerange2
gArea(homerange2,byid=T)/1e6
kud$'1'@h
str(kud)
kud
kud$'1'@h
kernel.area(kud,unout='km2')
gArea(homerange2,byid=T)/1e6
image(kud[[1]])
title("Output of kernelUD")
xyz <- as.image.SpatialGridDataFrame(kud[[1]])
contour(xyz, add=TRUE)
vud <- getvolumeUD(kud)
image(vud[[1]])
title("Output of getvolumeUD")
xyzv <- as.image.SpatialGridDataFrame(vud[[1]])
contour(xyzv, add=TRUE)
points(anim_sp_5243, cex= 0.01, col='blue')
vud <- getvolumeUD(kud)
image(vud[[1]])
title("Output of getvolumeUD")
xyzv <- as.image.SpatialGridDataFrame(vud[[1]])
contour(xyzv, add=TRUE)
points(mydf_sp_trans, cex= 0.01, col='blue')
kud[[1]]
image(kud[[2]])
image(kud)
xyz <- as.image.SpatialGridDataFrame(kud)
contour(xyz, add=TRUE)
xyz <- as.image.SpatialGridDataFrame(kud[[1]])
contour(xyz, add=TRUE)
xy <- coordinates(kud[[1]])
z <- kud[[1]]@data$ud
df_kud <- data.frame(x=xy[,1],y=xy[,2],z=z)
#persp(x=df_kud$x, y=df_kud$y, z= df_kud$z)
#plot3d(x=xy[,1],y=xy[,2],z=z)
kud[[1]]@grid@cells.dim
r <- raster(ncols=60,nrows=58)
coordinates(df_kud) <- ~x + y
r_kud <- rasterize(df_kud,r,'z',fun=max)
myz <- matrix(z ,nrow= kud[[1]]@grid@cells.dim[[2]],
ncol= kud[[1]]@grid@cells.dim[[1]],byrow=F)
# image(myz)
kd.list <- list(x=xy[,1],y=xy[,2],z=myz)
# with(kd.list, plot_ly(x = x, y = y, z = z, type = "surface"))
plot_ly(z = myz, type = "surface") # click into plot and on icon 'turntable rotation' in plot upper right
?vud
?getvolumeUD
image(kud[[1]])
image(kud[[2]])
xyz <- as.image.SpatialGridDataFrame(kud[[2]])
contour(xyz, add=TRUE)
vud <- getvolumeUD(kud)
image(vud[[1]])
image(kud[[1]])
image(kud[[1]], col= viridis(100))
image(kud[[1]], col= terrain(100))
?viridis
